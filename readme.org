#+title: Adaptive Sampling

A repository for robotic exploration in natural environments.

Main focus on information gathering on a 2D surface.

Written in Julia for speed and code flexibility.

Created by Nicholas Harrison.

* Installation and Setup
Download Julia and run installer: [[https://julialang.org/downloads/]]

Recommended to add julia to your path.

Use git to clone the repository to a local directory:
#+begin_src shell
git clone https://gitlab.acfr.usyd.edu.au/nhar0989/AdaptiveSampling.git
#+end_src

This will create a directory called =AdaptiveSampling=.

1. Navigate into the =AdaptiveSampling/src= directory on the command line
2. Run =julia --project= to enter the julia REPL and activate the project
3. Run =]instantiate= to install all needed packages
4. Exit the interactive Pkg mode by hitting backspace

** Extra notes
*** Activating a project
The =--project=<path>= flag automatically activates a project environment after starting the REPL. You can run this manually by =]activate <path>= within the julia REPL. Both of these forms accept the path to the directory that contains the =Project.toml= file, e.g. the root directory of this repository. If you are already within a project directory, you can simply run it without a value (=julia --project=) with the same effect.

*** rospy error
If you get: =Error: Unable to load the 'rospy' python package!=

1. Run =ENV["PYTHON"] = "/usr/bin/python"= (or whatever the path is to the python executable that has the rospy package installed)
2. Run =]build PyCall=
3. Restart the julia REPL

* Quick Start
To run the project in its current state, run =include("Main.jl")= at the julia REPL after following the steps in [[*Installation and Setup][Installation and Setup]].

That should be enough to get you started. Read on to understand more about the code and the Julia language in general.

* Code Parts and Usage Overview

The code is divided up into files to contain pieces with similar purposes or concepts in the algorithm. Each file has its own single module for defining a namespace used when importing its names into other files. Unlike many Julia packages, no names are exported by default to maintain clarity in what is used and where it comes from.

** Main.jl
The general scripting area and launching point for running the parts of the system. The main steps are initializing data, running the exploration algorithm, and visualizing results.

** Environment.jl
Types for holding and handling real and simulated data. Mainly used by [[*Initialization][Initialization]], but foundational for the other parts too. Its alias types ~Location~ and ~SampleInput~ are fundamental pieces for Samples and BeliefModels.

Main public types and functions:
- ~Location~
- ~SampleInput~
- ~Map~
- ~MultiMap~
- ~Region~
- ~imgToMap~
- ~res~
- ~pointToCell~
- ~GroundTruth~

** Initialization.jl
Functions for initializing mission data.

Main public types and functions:
- ~simData~
- ~realData~
- ~rosData~

** BeliefModels.jl
Everything to do with what is inferred about values in the environment. In practical terms: means, variances, and correlations. This is all built on Gaussian Processes.

Main public types and functions:
- ~BeliefModel~
- ~outputCorMat~

** Samples.jl
Everything to do with sampling values in the environment.

Main public types and functions:
- ~Sample~
- ~takeSamples~
- ~selectSampleLocation~
- ~SampleCost~

** Paths.jl
Searching for paths on a 2D grid using A*. Its main use is to get the path cost (distance), but it can return the full path as well.

Main public types and functions:
- ~PathCost~
- ~finalOrientation~
- ~getPath~

** Exploration.jl
Contains the function that runs the entire search mission. The entry-point to the actual adaptive sampling. This contains the main loop and most of the usage of Samples and BeliefModels.

Main public types and functions:
- ~explore~

** Visualization.jl
Methods to visualize mission data. The form displayed is determined by what data types are passed in.

Main public types and functions:
- ~visualize~

** ROSInterface.jl
The interface for passing data to and from other ROS nodes. It sets up an =adaptive_sampling= node and provides methods to handle the data. This is designed specifically for communication with Swagbot.

* Code Patterns

** Naming
The chosen naming conventions for the project:
- Types (data structures) are ~UpperCamelCase~
- Functions (and functors) are ~lowerCamelCase~
- Simple constants are ~CAPITAL_SNAKE_CASE~
- All other variables are ~snake_case~

** Data structures and functions
A consistent pattern is followed for most data and functions in this repo using the Julia language feature of functors. A functor is a combination of a struct and a function. In many places in the code, you will find the following in order:
1. a struct definition -- what data the functor contains
2. zero to many constructor definitions -- how it is initialized
3. zero to many method definitions -- what the functor does when it is called (possibly with arguments)


A functor's methods are meant to be the primary purpose of that object. e.g. a BeliefModel returns the belief, a SampleCost returns the sample cost, etc. If an object's data are used in any secondary way, it will be its own separate function with its own name, and the object will be passed in directly.

* Julia Tips
** Environment
These instructions focus on getting started up just using the REPL, which can be a sufficient set of tools. If you want to use an IDE, VSCode with the Julia extension is the main one recommended. It is supported by the Julia contributors and the community as a whole. You'll need to read their docs to learn how to use it.

** REPL
Julia ships with a useful REPL that combines an interpreter, a documentation browser, a package manager, and a shell. The four modes are accessed by typing the following keys:
- Interpreter: default mode
- Help: =?=
- Packages: =]=
- Shell: =;=
Type backspace or ctrl-c to exit a mode.

** Compilation
Julia code gets compiled the first time you run it. This means the first run will be slower and later ones much faster. This is also true when loading packages with ~using~ or ~import~. So the typical way to run julia code is through a REPL that is kept open between runs in order to not re-compile. If a script is run directly from the command line using the julia interpreter, it will be re-compiled every time. Running code within an IDE will typically keep a REPL open for you.

Note: Julia 1.9 reduces the load and first-execution times considerably for modules that have not changed. Highly recommended.

** Revise.jl
This is a great package to use when developing code (not needed when only running it). Normally to update methods and variables that have changed, you have to manually re-run the changed code in the REPL. This package tracks modules that you have included with ~using~ or ~import~ and automatically updates the running environment with any changes. Simply run ~using Revise~ /before/ ~using~ anything else (i.e. running the Main.jl file) and all your changes within the project will be tracked.

** Unchangeable stuff
Julia doesn't allow changing type definitions. This means if you need to change what is within a ~struct~ or you need use the name of a function for something else, you will need to restart the REPL.

** Functions and Methods
In Julia lingo, a function is a type given to a family of methods, which are all called with the given function name. The methods are specific implementations or instantiations of that function, which are based on the number and types of the arguments passed in.

Example:
#+begin_example
julia> length # the function
length (generic function with 226 methods)

julia> ?length("text") # one method
length(s::AbstractString) -> Int
...continued...

julia> ?length([1,2,3]) # a different method
length(A::AbstractArray)
...continued...
#+end_example

** Timing, Profiling, and Debugging
The following packages can be useful when developing and analyzing the code.

*** Timing
The easiest way to time code is simply by putting ~@time~ in front of a line of code. If you want to time multiple lines, put them inside a ~@time begin ... end~ block.

To automate multiple runs of the code and get statistical information, use [[https://github.com/JuliaCI/BenchmarkTools.jl][BenchmarkTools.jl]] and the ~@benchmark~ or ~@btime~ macros.

*** Profiling
Reference: [[https://docs.julialang.org/en/v1/manual/profile/]]

~using Profile~

Same as timing, just put ~@profile~ before the code you want profiled. To see the output run ~Profile.print()~.

I like using [[https://github.com/tkluck/StatProfilerHTML.jl][StatProfilerHTML.jl]] for viewing the output. Can also use [[https://github.com/timholy/ProfileView.jl][ProfileView.jl]]. They each have their own shortcut commands for profiling and viewing. See their pages.

*** Debugging
Reference: [[https://github.com/JuliaDebug/Debugger.jl]]

~using Debugger~

Put ~@run~ or ~@enter~ before code to debug. Use the commands from the docs in the REPL.

** Finding source module of object
To get the module that an object comes from, you can use
#+begin_src julia
parentmodule(ImportedType) # will tell you which module a function or type comes from
parentmodule(typeof(var)) # for the object a variable contains, get the type first
#+end_src

In this project all names used are explicitly imported at the top of the file to help new developers.
