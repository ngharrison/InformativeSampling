var documenterSearchIndex = {"docs":
[{"location":"code_patterns.html#Code-Patterns","page":"Code Patterns","title":"Code Patterns","text":"","category":"section"},{"location":"code_patterns.html#Naming","page":"Code Patterns","title":"Naming","text":"","category":"section"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"The chosen naming conventions for the project:","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"Types (data structures) are UpperCamelCase\nFunctions (and callable types) are lowerCamelCase\nSimple constants are CAPITAL_SNAKE_CASE\nAll other variables are snake_case","category":"page"},{"location":"code_patterns.html#Data-structures-and-functions","page":"Code Patterns","title":"Data structures and functions","text":"","category":"section"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"A consistent pattern is followed for most data and functions in this repo using the Julia language feature of callable types. Defined data types can be given associated methods to make them callable. In many places in the code, you will find the following in order:","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"a struct definition – what data is contained\nzero to many constructor definitions – how it is initialized\nzero to many method definitions – what it does when it is called (possibly with arguments)","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"As an example, here is a simplified version of the GridMap type:","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"# struct definition\nstruct GridMap\n    data\n    bounds\nend\n\n# constructor definition\nGridMap(data) = GridMap(data, (lower=[0.0, 0.0], upper=[1.0, 1.0]))\n\n# method definition, returns the value at that location\nfunction (map::GridMap)(x::Location)\n    checkBounds(x, map)\n    map.data[pointToCell(x, map)]\nend","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"It can then be used like:","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"data = reshape(1:25, 5, 5)\nm = GridMap(data) # initialize through constructor\n\nx = [.2, .75]\nval = m(x) # call method to perform its function and get result","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"The type's methods are meant to be the primary purpose of that object. e.g. a BeliefModel returns the belief, a SampleCost returns the sample cost, etc. If an object's data are used in any secondary way, it will be its own separate function with its own name, and the object will be passed in directly. e.g. quantityCorMat(beliefModel::BeliefModel).","category":"page"},{"location":"core.html#Core-–-Parts-and-Usage-Overview","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"The code is divided up into files to contain pieces with similar purposes or concepts in the algorithm. Each file has its own single module for defining a namespace used when importing its names into other files. Each module exports members intended for public access, but the code in this project explicitly names its imports to maintain clarity in what is used and where it comes from.","category":"page"},{"location":"core.html#Missions.jl","page":"Core –- Parts and Usage Overview","title":"Missions.jl","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"Modules = [Missions]","category":"page"},{"location":"core.html#InformativeSampling.Missions","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Missions","text":"This module contains functions for initializing mission data and the function for running the entire search mission. The entry-point to the actual informative sampling. This contains the main loop and most of the usage of Samples and belief models.\n\nMain public types and functions:\n\nMission\nreplay\n\n\n\n\n\n","category":"module"},{"location":"core.html#InformativeSampling.Missions.Mission","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Missions.Mission","text":"The main function that runs the informative sampling routine. For each iteration, a sample location is selected, a sample is collected, the belief model is updated, and visuals are possibly shown. The run finishes when the designated number of samples is collected.\n\nInputs:\n\nfunc: any function to be run at the end of the update loop, useful for visualization or saving data (default does nothing)\nsamples: a vector of samples, this can be used to jump-start a mission or resume a previous mission (default empty)\nbeliefs: a vector of beliefs, this pairs with the previous argument (default empty)\nseed_val: the seed for the random number generator, an integer (default 0)\nsleep_time: the amount of time to wait after each iteration, useful for visualizations (default 0)\n\nOutputs:\n\nsamples: a vector of new samples collected\nbeliefs: a vector of probabilistic representations of the quantities being searched for, one for each sample collection\n\nExamples\n\nusing Missions: synMission\n\nmission = synMission(num_samples=10) # create the specific mission\nsamples, beliefs = mission(visuals=true, sleep_time=0.5) # run the mission\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Missions.Mission-2","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Missions.Mission","text":"Fields:\n\noccupancy::Any: an occupancy map, true in cells that are occupied\nsampler::Any: a function that returns a measurement value for any input\nnum_samples::Any: the number of samples to collect in one run\nsampleCostType::Any: a constructor for the function that returns the (negated) value of taking a sample (default DistScaledEIGF)\nweights::Any: weights for picking the next sample location\nstart_locs::Any: the locations that should be sampled first (default [])\nprior_samples::Any: any samples taken previously (default empty)\nkernel::Any: the kernel to be used in the belief model (default multiKernel)\nmeans_use::Any: whether or not to use a non-zero mean for each quantity (default true)\nmeans_learn::Any: whether or not to learn means (default false)\nnoise_value::Any: a named tuple of noise value(s) (default [0.0, 0.0, ...])\nnoise_learn::Any: whether or not to learn noise further (default false)\nuse_cond_pdf::Any: whether or not to use the conditional distribution of the data to train the belief model (default false)\nhyp_drop::Any: whether or not to drop hypotheses and settings for it (default (false, 10, 5, 0.4))\n\nDefined as a keyword struct, so all arguments are passed in as keywords:\n\nmission = Mission(; occupancy,\n                  sampler,\n                  num_samples,\n                  sampleCostType,\n                  weights,\n                  start_locs,\n                  prior_samples,\n                  noise,\n                  kernel)\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Missions.replay-Tuple{Any, InformativeSampling.Missions.Mission, Any, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Missions.replay","text":"replay(\n    func,\n    M::InformativeSampling.Missions.Mission,\n    full_samples,\n    beliefs;\n    sleep_time\n)\n\n\nReplays a mission that has already taken place. Mainly for visualization purposes.\n\nInputs:\n\nfunc: any function to be run at the end of the update loop, useful for\n\nvisualization or saving data (default does nothing)\n\nfull_samples: a vector of samples\nbeliefs: a vector of beliefs\nsleep_time: the amount of time to wait after each iteration, useful for\n\nvisualizations (default 0)\n\n\n\n\n\n","category":"method"},{"location":"core.html#Samples.jl","page":"Core –- Parts and Usage Overview","title":"Samples.jl","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"Modules = [Samples]","category":"page"},{"location":"core.html#InformativeSampling.Samples","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples","text":"This module contains everything to do with sampling values in the environment. Its alias types Location and SampleInput are fundamental pieces for MultiQuantityGPs as well.\n\nMain public types and functions:\n\nGridMapsSampler\nLocation\nSample\nSampleInput\nUserSampler\nselectSampleLocation\ntakeSamples\n\n\n\n\n\n","category":"module"},{"location":"core.html#InformativeSampling.Samples.GridMapsSampler","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.GridMapsSampler","text":"Handles samples of the form (location, quantity) to give the value from the right map. Internally a tuple of GridMaps.\n\nConstructor can take in a tuple or vector of GridMaps or each GridMap as a separate argument.\n\nExamples\n\nss = GridMapsSampler(GridMap(zeros(5, 5)), GridMap(ones(5, 5)))\n\nloc = [.2, .75]\nss(loc) # result: [0, 1]\nss((loc, 2)) # result: 1\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.Location","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.Location","text":"mutable struct Array{Float64, 1} <: DenseVector{Float64}\n\nLocation of sample\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.Sample","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.Sample","text":"Struct to hold the input and output of a sample.\n\nFields:\n\nx::Tuple{Vector{Float64}, Int64}: the sample input, usually a location and sensor id\ny::Any: the sample output or observation, a scalar\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.SampleInput","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.SampleInput","text":"struct Tuple{Vector{Float64}, Int64}\n\nSample input, the combination of: (Location, sensor index)\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.SampleOutput","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.SampleOutput","text":"struct Tuple{Float64, Float64}\n\nValue of sample measurement, the measurement mean and standard deviation\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.UserSampler","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.UserSampler","text":"A sampler that asks the user to input measurement values, one for each quantity at the given location.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.selectSampleLocation-Tuple{Any, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.selectSampleLocation","text":"selectSampleLocation(sampleCost, bounds) -> AbstractArray\n\n\nThe optimization of choosing a best single sample location.\n\nInputs:\n\nsampleCost: a function from sample location to cost (x->cost(x))\nbounds: map lower and upper bounds\n\nReturns the sample location, a vector\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Samples.takeSamples-Tuple{Any, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.takeSamples","text":"takeSamples(loc, sampler) -> Any\n\n\nPulls a ground truth value from a given location and constructs a Sample object to hold them both.\n\nInputs:\n\nloc: the location to sample\nsampler: a function that returns ground truth values\nquantities: (optional) a vector of integers which represent which quantities to sample, defaults to all of them\n\nOutputs a vector of Samples containing input x and measurement y\n\n\n\n\n\n","category":"method"},{"location":"core.html#SampleCosts.jl","page":"Core –- Parts and Usage Overview","title":"SampleCosts.jl","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"Modules = [SampleCosts]","category":"page"},{"location":"core.html#InformativeSampling.SampleCosts","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts","text":"This module holds a variety of SampleCost functions used by Samples.jl in selecting a new sample location. The purpose is to pick the location that will minimize the given function.\n\nEach sample cost function in this module is a subtype of the abstract SampleCost type. Their common interface consists of two functions:\n\nvalues(sampleCost, location): returns the values of the terms (μ, σ, τ, P);\n                                this is typically what each subtype will override;\n                                in all of these, μ = belief model mean, σ = belief model std,                                 τ = travel distance, P = proximity value;\n                                all of these are for the specific location\nsampleCost(location): the actual sample cost at the location; it has a                         default method explained in SampleCost;\n                        for the equations the location is denoted x\n\nMany of these were experiment cost functions and aren't recommended. The main ones recommended for use, in order, are\n\nDistScaledEIGF\nEIGF\nMIPT\nOnlyVar\n\nOthers can be useful if one wants to do some more experimentation. Note that all these functions are currently hardcoded to use the first quantity as the objective quantity unless otherwise stated. Unless explicitly used, the distance value is generally used to make sure unreachable locations are forbidden (their value will be Inf).\n\nMain public types and functions:\n\nDerivVar\nDistLogEIGF\nDistProx\nDistScaledDerivVar\nDistScaledEIGF\nEIGF\nInfoGain\nLogLikelihood\nLogLikelihoodFull\nLogNormed\nMIPT\nOnlyVar\nSampleCost\nVarTrace\nvalues\n\n\n\n\n\n","category":"module"},{"location":"core.html#InformativeSampling.SampleCosts.DerivVar","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.DerivVar","text":"Uses the norm of the derivative of the belief model mean and the belief model variance:\n\nC(x) = - w_1  leftlVert fracpartial μpartial x(x) rightrVert^2 - w_2  σ^2(x)\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.DistLogEIGF","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.DistLogEIGF","text":"A variation on EIGF that takes the logarithm of the variance and adds a distance cost term that is normalized by the average of the region dimensions:\n\nC(x) = - w_1  (μ(x) - y(x_c))^2 - w_2  log(σ^2(x)) +\n       w_3  β  fracτ(x)leftlVert boldsymbolell_d rightrVert_1\n\nwhere β is a parameter to delay the distance effect until a few samples have been taken.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.DistProx","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.DistProx","text":"Combines the average mean value, average standard deviation, travel distance, and proximity as terms:\n\nC(x) = - w_1  μ_mathrmave(x) - w_2  σ_mathrmave(x) +\n       w_3  τ(x) + w_4  P(x)\n\nwhere P(x) = sum_i(fracmin(boldsymbolell_d)4  mathrmdist_i)^3. Averages are performed over all quantities.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.DistScaledDerivVar","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.DistScaledDerivVar","text":"Uses the norm of the derivative of the belief model mean and the belief model variance, then scales it all by a normalized travel distance:\n\nC(x) = frac- w_1  leftlVert fracpartial μpartial x(x) rightrVert^2 - w_2  σ^2(x)\n       1 + β  fracτ(x)leftlVert boldsymbolell_d rightrVert_1\n\nwhere β is a parameter to delay the distance effect until a few samples have been taken.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.DistScaledEIGF","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.DistScaledEIGF","text":"Augments EIGF with a factor to scale by a normalized travel distance:\n\nC(x) = frac- w_1  (μ(x) - y(x_c))^2 - w_2  σ^2(x)\n1 + β  fracτ(x)leftlVert boldsymbolell_d rightrVert_1\n\nwhere β is a parameter to delay the distance effect until a few samples have been taken.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.EIGF","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.EIGF","text":"Expected Informativeness for Global Fit (EIGF). This function is adapted from [Lam] through added weights to choose the balance between exploration and exploitation. It has the form:\n\nC(x) = - w_1  (μ(x) - y(x_c))^2 - w_2  σ^2(x)\n\nwhere x_c is the nearest collected sample location.\n\n[Lam]: Lam, C Q (2008) Sequential adaptive designs in computer experiments for response surface model fit (Doctoral dissertation). The Ohio State University.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.InfoGain","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.InfoGain","text":"Derived from the idea of information gain across the region. Returns the entropy of a set of points (10x10 grid) given the new sample location. Minimizing this entropy is equivalent to maximizing information gain since the entropy before the sample is always the same.\n\nThis function is very computationally expensive, which is why the test grid is set at 10x10.\n\nIt has the form:\n\nC(x) = log Σ\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.LogLikelihood","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.LogLikelihood","text":"Idea derived from the log likelihood of query location. Similar to EIGF, the measured value from the nearest sample is used:\n\nC(x) = - w_1  left( fracμ(x) - y(x_c)σ_n right)^2 - w_2  log (σ^2(x))\n\nwhere x_c is the nearest collected sample location, and σ_n is the noise.\n\nThis function was seen to work well but hasn't undergone extensive tests. There is still some question about the theory and the use of noise parameter vs signal amplitude parameter.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.LogLikelihoodFull","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.LogLikelihoodFull","text":"A test of the log likelihood idea but using a weighted sum of all measured sample values, not just the nearest one:\n\nC(x) = - w_1  frac1sum_i k(x x_i) sum_i k(x x_i) *\n       left( fracμ(x) - y(x_i)σ_n right)^2 - w_2  log (σ^2(x))\n\nwhere x_i is each collected sample location, and σ_n is the noise.\n\nThis function's performance wasn't satisfactory.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.LogNormed","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.LogNormed","text":"Combines the average belief value and the log of the average uncertainty value of all quantities. All belief and uncertainty values are first normalized by the maximum belief value of that quantity. It has the form:\n\nC(x) = - w_1  μ_textrmnorm-ave(x) - w_2  log (σ_textrmnorm-ave(x))\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.MEPE","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.MEPE","text":"This was a cost function being considered but wasn't finished. Taken from [Liu].\n\n[Liu]: Liu H, Cai J, Ong Y (2017) An adaptive sampling approach for kriging metamodeling by maximizing expected prediction error. Comput Chem Eng 106:171–182\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.MIPT","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.MIPT","text":"A simple cost function that doesn't use a belief model but works purely on distances. It returns the negated distance to the nearest sample:\n\nC(x) = - min_i leftlVert x - x_i rightrVert\n\nUseful when maximizing distance between samples.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.OnlyVar","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.OnlyVar","text":"Returns the negated variance of the belief model at the query location:\n\nC(x) = - σ^2\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.SampleCost","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.SampleCost","text":"Typically construct a SampleCost through SampleCostType(occupancy, samples, beliefModel, quantities, weights)\n\nA pathCost is constructed automatically from the other arguments.\n\nThis object can then be called to get the cost of sampling at a location: sampleCost(x)\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.SampleCost-Tuple{Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.SampleCost","text":"Cost to take a new sample at a location x. This is a fallback method that calculates a simple linear combination of all the values of a SampleCost.\n\nHas the form:\n\nC(x) = - w_1  μ(x) - w_2  σ(x) + w_3  τ(x) + w_4  P(x)\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.SampleCosts.VarTrace","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.VarTrace","text":"Similar to InfoGain but uses only variances rather than the full covariance matrix, which is the same as the trace instead of the log determinant. This reduces computation but is still more costly than a single point estimate. This uses a 20x20 grid of test points.\n\nIt has the form:\n\nC(x) = textrmtr(Σ)\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.values-Tuple{InformativeSampling.SampleCosts.SampleCost, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.values","text":"values(\n    sc::InformativeSampling.SampleCosts.SampleCost,\n    loc\n) -> Tuple{Float64, Any, Float64, Float64}\n\n\nReturns the values to be used to calculate the sample cost (belief mean, standard deviation, travel distance, sample proximity).\n\nEach concrete subtype of SampleCost needs to implement.\n\nThis can be a useful function to inspect values during optimization.\n\n\n\n\n\n","category":"method"},{"location":"julia_tips.html#Julia-Tips","page":"Julia Tips","title":"Julia Tips","text":"","category":"section"},{"location":"julia_tips.html#Development-Environment","page":"Julia Tips","title":"Development Environment","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"These instructions focus on getting started up just using the REPL, which can be a sufficient set of tools. If you want to use an IDE, VSCode with the Julia extension is the main one recommended. It is supported by the Julia contributors and the community as a whole. You'll need to read their docs to learn how to use it.","category":"page"},{"location":"julia_tips.html#REPL","page":"Julia Tips","title":"REPL","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Julia ships with a useful REPL that combines an interpreter, a documentation browser, a package manager, and a shell. The four modes are accessed by typing the following keys:","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Interpreter: default mode\nHelp: ?\nPackages: ]\nShell: ;","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Type backspace or ctrl-c to exit a mode.","category":"page"},{"location":"julia_tips.html#Compilation","page":"Julia Tips","title":"Compilation","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Julia code gets compiled the first time you run it. This means the first run will be slower and later ones much faster. This is also true when loading packages with using or import. So the typical way to run julia code is through a REPL that is kept open between runs in order to not re-compile. If a script is run directly from the command line using the julia interpreter, it will be re-compiled every time. Running code within an IDE will typically keep a REPL open for you.","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Note: Since Julia 1.9 load and first-execution times have been considerably reduced for modules that have not changed. It does this through pre-compilation and caching. Highly recommended. A few extra seconds on first run time are typical, similar to re-compiling C++ code before running it.","category":"page"},{"location":"julia_tips.html#Revise.jl","page":"Julia Tips","title":"Revise.jl","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"This is a great package to use when developing code (not needed when only running it). Normally to update methods and variables that have changed, you have to manually re-run the changed code in the REPL. This package tracks modules that you have included with using or import and automatically updates the running environment with any changes. Simply run using Revise before using anything else (i.e. running the Main.jl file) and all your changes within the project will be tracked.","category":"page"},{"location":"julia_tips.html#Unchangeable-stuff","page":"Julia Tips","title":"Unchangeable stuff","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Julia doesn't allow changing type definitions. This means if you need to change what is within a struct or you need use the name of a function for something else, you will need to restart the REPL.","category":"page"},{"location":"julia_tips.html#Functions-and-Methods","page":"Julia Tips","title":"Functions and Methods","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"In Julia lingo, a function is a type given to a family of methods, which are all called with the given function name. The methods are specific implementations or instantiations of that function, which are based on the number and types of the arguments passed in.","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Example:","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"julia> length # the function\nlength (generic function with 226 methods)\n\njulia> ?length(\"text\") # one method\nlength(s::AbstractString) -> Int\n...continued...\n\njulia> ?length([1,2,3]) # a different method\nlength(A::AbstractArray)\n...continued...","category":"page"},{"location":"julia_tips.html#Timing,-Profiling,-and-Debugging","page":"Julia Tips","title":"Timing, Profiling, and Debugging","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"The following packages can be useful when developing and analyzing the code.","category":"page"},{"location":"julia_tips.html#Timing","page":"Julia Tips","title":"Timing","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"The easiest way to time code is simply by putting @time in front of a line of code. If you want to time multiple lines, put them inside a @time begin ... end block.","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"To automate multiple runs of the code and get statistical information, use BenchmarkTools.jl and the @benchmark or @btime macros.","category":"page"},{"location":"julia_tips.html#Profiling","page":"Julia Tips","title":"Profiling","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Reference: https://docs.julialang.org/en/v1/manual/profile/","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"using Profile","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Same as timing, just put @profile before the code you want profiled. To see the output run Profile.print().","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"I like using StatProfilerHTML.jl for viewing the output. Can also use ProfileView.jl. They each have their own shortcut commands for profiling and viewing. See their pages.","category":"page"},{"location":"julia_tips.html#Debugging","page":"Julia Tips","title":"Debugging","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Reference: https://github.com/JuliaDebug/Debugger.jl","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"using Debugger","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Put @run or @enter before code to debug. Use the commands from the docs in the REPL.","category":"page"},{"location":"julia_tips.html#Finding-source-module-of-object","page":"Julia Tips","title":"Finding source module of object","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"To get the module that an object comes from, you can use","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"parentmodule(ImportedType) # will tell you which module a function or type comes from\nparentmodule(typeof(var)) # for the object a variable contains, get the type first","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"In this project all names used are explicitly imported at the top of the file to help new developers.","category":"page"},{"location":"application.html#Application-–-Parts-and-Usage-Overview","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"Scripts that run the informative sampling code. This is the starting place for use of the repository and it uses the other parts: core and utils.","category":"page"},{"location":"application.html#missions","page":"Application –- Parts and Usage Overview","title":"missions","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The place where code to run missions is located.","category":"page"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The launching point for running the informative sampling missions. The main steps are initializing data, running the algorithm, and visualizing/saving results.","category":"page"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The example.jl script can be run to see the full code in action.","category":"page"},{"location":"application.html#scripts","page":"Application –- Parts and Usage Overview","title":"scripts","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The place where code to analyze saved data is located.","category":"page"},{"location":"application.html#ros","page":"Application –- Parts and Usage Overview","title":"ros","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"A python files used to test simple usage with ROS.","category":"page"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"Also contains the server.jl script which handles ROS service requests and the ROSInterface.jl module file that implements a sampler that uses ROS communication to handle sampling within a mission.","category":"page"},{"location":"application.html#maps","page":"Application –- Parts and Usage Overview","title":"maps","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The place where maps used as data are stored.","category":"page"},{"location":"application.html#output","page":"Application –- Parts and Usage Overview","title":"output","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The place that files are saved from the code by default.","category":"page"},{"location":"utilities.html#Utilities-–-Parts-and-Usage-Overview","page":"Utilities –- Parts and Usage Overview","title":"Utilities –- Parts and Usage Overview","text":"","category":"section"},{"location":"utilities.html","page":"Utilities –- Parts and Usage Overview","title":"Utilities –- Parts and Usage Overview","text":"Modules for auxiliary functions used with the core informative sampling.","category":"page"},{"location":"utilities.html#DataIO.jl","page":"Utilities –- Parts and Usage Overview","title":"DataIO.jl","text":"","category":"section"},{"location":"utilities.html","page":"Utilities –- Parts and Usage Overview","title":"Utilities –- Parts and Usage Overview","text":"Modules = [DataIO]","category":"page"},{"location":"utilities.html#InformativeSamplingUtils.DataIO","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO","text":"A module for handling data in and out.\n\nMain public types and functions:\n\nimgToMap\nmaps_dir\nnormalize\noutput_dir\noutput_ext\nproduceMap\nproduceMaps\nsave\nsaveBeliefMapToPng\nspatialAve\n\n\n\n\n\n","category":"module"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.maps_dir","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.maps_dir","text":"The default directory containing the maps that can be used as data during simulated sampling.\n\n\n\n\n\n","category":"constant"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.output_dir","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.output_dir","text":"The default output directory where files can be saved.\n\n\n\n\n\n","category":"constant"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.output_ext","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.output_ext","text":"The default extension for saved output files.\n\n\n\n\n\n","category":"constant"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.GaussGroundTruth","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.GaussGroundTruth","text":"Struct/function for generating ground truth values from a linear combination of gaussian peaks.\n\nExamples\n\nGaussGroundTruth(peaks) # pass in a list of Peaks\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.GaussGroundTruth-Tuple{Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.GaussGroundTruth","text":"Produces ground-truth value(s) for a point or list of points. Accepts a single vector, a vector of vectors, or a matrix of column vectors.\n\nEach probability distribution component is divided by its own peak height and the highest of all the peaks before being added into the total. This causes the entire ground truth map to have a max value of (about) 1.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.Peak","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.Peak","text":"Used within a GaussGroundTruth. Holds a 2D normal distribution and the desired height of the peak.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.Peak-Tuple{Any, Any, Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.Peak","text":"Inputs:\n\nμ: the peak location (distribution mean)\nΣ: the peak width (distribution covariance)\nh: the peak height\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.dateTimeString","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.dateTimeString","text":"Creates a string containing the date and time separated by dashes. Can pass in a DateTime object, defaults to current time.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.imgToMap-Tuple{Any, Vararg{Any}}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.imgToMap","text":"Takes a matrix in the format created from an image, re-formats it, and returns a GridMap. Images view a matrix with its indexing top-down and left-right. GridMaps view a matrix with its indexing left-right and bottom-up.\n\nExamples\n\nusing DelimitedFiles: readdlm\n\nimage = readdlm(file_name, ',')\nbounds = (lower = [0.0, 0.0], upper = [1.0, 1.0])\nmap = imgToMap(image, bounds)\nmap = imgToMap(image) # or auto bounds\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.normalize-Tuple{Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.normalize","text":"A helper method to normalize an array so its values are within the range [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.produceMap-Tuple{Any, GridMaps.GridMap}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.produceMap","text":"produceMap(\n    func,\n    map::GridMaps.GridMap\n) -> Union{GridMaps.GridMap{_A, _B, _C, Float64} where {_B, _C<:AbstractArray{_A, _B}}, GridMaps.GridMap{_A, N, _C, Float64} where {N, _C<:AbstractArray{_A, N}}} where _A\n\n\nGenerates a GridMap from a function for chosen bounds and dimensions. Can also pass in another GridMap in place of bounds and dims.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.produceMaps-Tuple{MultiQuantityGPs.MQGP, GridMaps.GridMap}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.produceMaps","text":"produceMaps(\n    beliefModel::MultiQuantityGPs.MQGP,\n    map::GridMaps.GridMap;\n    quantity\n) -> Tuple{Union{GridMaps.GridMap{_A, _B, _C, Float64} where {_B, _C<:AbstractArray{_A, _B}}, GridMaps.GridMap{_A, N, _C, Float64} where {N, _C<:AbstractArray{_A, N}}} where _A, Union{GridMaps.GridMap{_A, _B, _C, Float64} where {_B, _C<:AbstractArray{_A, _B}}, GridMaps.GridMap{_A, N, _C, Float64} where {N, _C<:AbstractArray{_A, N}}} where _A}\n\n\nGenerates belief and uncertainty GridMaps from a belief model for chosen bounds and dimensions. Can also pass in another GridMap in place of bounds and dims.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.save-NTuple{4, Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.save","text":"save(\n    mission,\n    samples,\n    beliefs,\n    times;\n    animation,\n    sub_dir_name,\n    file_name\n) -> Union{Nothing, Plots.AnimatedGif}\n\n\nA collection of methods for saving data from missions, metrics, and general julia objects.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.saveBeliefMapToPng","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.saveBeliefMapToPng","text":"saveBeliefMapToPng(beliefModel, occupancy) -> Any\nsaveBeliefMapToPng(beliefModel, occupancy, file_name) -> Any\n\n\nThis is really just to give something out to munch, so it needs to be an rgba png with the last channel as the amount.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.spatialAve","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.spatialAve","text":"A helper method to perform a spatial average on a matrix. The extent of the average can be chosen with its default being 1.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#Visualization.jl","page":"Utilities –- Parts and Usage Overview","title":"Visualization.jl","text":"","category":"section"},{"location":"utilities.html","page":"Utilities –- Parts and Usage Overview","title":"Utilities –- Parts and Usage Overview","text":"Modules = [Visualization]","category":"page"},{"location":"utilities.html#InformativeSamplingUtils.Visualization","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization","text":"A module with methods to visualize mission data. The form displayed is determined by what data types are passed in.\n\nMain public types and functions:\n\nvis\nvisualize\n\n\n\n\n\n","category":"module"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.getAxes-Tuple{Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.getAxes","text":"getAxes(map) -> Tuple{Any, Any}\n\n\nMethod to get the x and y plotting axes. This (re)generates them only if needed and saves them into global module variables for future use.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.vis","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.vis","text":"Simple convenience function that also displays the output of any visualize function. See those.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(map::GridMaps.GridMap; ...) -> Any\nvisualize(map::GridMaps.GridMap, title; points, clim) -> Any\n\n\nMethod to show any GridMap data.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-2","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(\n    beliefModel::MultiQuantityGPs.MQGP,\n    samples,\n    occupancy;\n    ...\n) -> Any\nvisualize(\n    beliefModel::MultiQuantityGPs.MQGP,\n    samples,\n    occupancy,\n    new_loc;\n    quantity\n) -> Any\n\n\nMethod to show belief model values of mean and standard deviation and the sample locations that they were generated from. Shows two plots side-by-side.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-3","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(sampleCost, samples, occupancy) -> Any\nvisualize(sampleCost, samples, occupancy, new_loc) -> Any\n\n\nMethod to show sample cost values.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-Tuple{Any, Any, MultiQuantityGPs.MQGP, Any, Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(\n    md,\n    samples,\n    beliefModel::MultiQuantityGPs.MQGP,\n    sampleCost,\n    new_loc;\n    quantity\n) -> Any\n\n\nMain method to visualize the current state of a search. Generates all the other visuals through their respective methods and lays them out in a grid. Currently shows the belief model, the ground truth, and the obstacles.\n\nArguments pass through to the sub-methods that need them. res is the grid resolution when plotting continuous-valued functions and defaults to [0.01, 0.01].\n\nIf no ground truth is available, it is not plotted.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-Tuple{Any, Any, MultiQuantityGPs.MQGP, Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(\n    md,\n    samples,\n    beliefModel::MultiQuantityGPs.MQGP,\n    new_loc;\n    quantity\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-Tuple{Any, Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(sampler, map) -> Any\n\n\nMethod to show ground truth data from a function.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-Tuple{Vararg{GridMaps.GridMap}}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(maps::GridMaps.GridMap...; titles, points) -> Any\n\n\nMethod to show a ground truth map and up to three other prior data maps. Pass each map in as its own argument.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#Metrics.jl","page":"Utilities –- Parts and Usage Overview","title":"Metrics.jl","text":"","category":"section"},{"location":"utilities.html","page":"Utilities –- Parts and Usage Overview","title":"Utilities –- Parts and Usage Overview","text":"Modules = [Metrics]","category":"page"},{"location":"utilities.html#InformativeSamplingUtils.Metrics","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Metrics","text":"A module to calculate the metrics from a mission and belief model.\n\nMain public types and functions:\n\ncalcMetrics\n\n\n\n\n\n","category":"module"},{"location":"utilities.html#InformativeSamplingUtils.Metrics.calcMetrics","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Metrics.calcMetrics","text":"A collection of methods that calculates metrics from sampling missions.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"This repository is divided into three parts: a core package, utilities, and an application.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"The package is the core functionality –- the general informative sampling routine. This part includes things like the belief models, map data structures, sample selection optimization, and the main mission loop.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"The utilities are things that deal with informative sampling data –- both inputs and outputs. They provide common routines to aid in constructing, visualizing, and analyzing missions.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"The application is code that uses and tests the informative sampling package in specific scenarios. It contains the data itself and scripts to run all the other code.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"See the sections in the sidebar to learn more details. ","category":"page"}]
}
