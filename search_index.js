var documenterSearchIndex = {"docs":
[{"location":"code_patterns.html#Code-Patterns","page":"Code Patterns","title":"Code Patterns","text":"","category":"section"},{"location":"code_patterns.html#Naming","page":"Code Patterns","title":"Naming","text":"","category":"section"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"The chosen naming conventions for the project:","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"Types (data structures) are UpperCamelCase\nFunctions (and callable types) are lowerCamelCase\nSimple constants are CAPITAL_SNAKE_CASE\nAll other variables are snake_case","category":"page"},{"location":"code_patterns.html#Data-structures-and-functions","page":"Code Patterns","title":"Data structures and functions","text":"","category":"section"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"A consistent pattern is followed for most data and functions in this repo using the Julia language feature of callable types. Defined data types can be given associated methods to make them callable. In many places in the code, you will find the following in order:","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"a struct definition – what data is contained\nzero to many constructor definitions – how it is initialized\nzero to many method definitions – what it does when it is called (possibly with arguments)","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"As an example, here is a simplified version of the Map type:","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"# struct definition\nstruct Map\n    data\n    bounds\nend\n\n# constructor definition\nMap(data) = Map(data, (lower=[0.0, 0.0], upper=[1.0, 1.0]))\n\n# method definition, returns the value at that location\nfunction (map::Map)(x::Location)\n    checkBounds(x, map)\n    map.data[pointToCell(x, map)]\nend","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"It can then be used like:","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"data = reshape(1:25, 5, 5)\nm = Map(data) # initialize through constructor\n\nx = [.2, .75]\nval = m(x) # call method to perform its function and get result","category":"page"},{"location":"code_patterns.html","page":"Code Patterns","title":"Code Patterns","text":"The type's methods are meant to be the primary purpose of that object. e.g. a BeliefModel returns the belief, a SampleCost returns the sample cost, etc. If an object's data are used in any secondary way, it will be its own separate function with its own name, and the object will be passed in directly. e.g. outputCorMat(beliefModel::BeliefModel).","category":"page"},{"location":"core.html#Core-–-Parts-and-Usage-Overview","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"The code is divided up into files to contain pieces with similar purposes or concepts in the algorithm. Each file has its own single module for defining a namespace used when importing its names into other files. Each module exports members intended for public access, but the code in this project explicitly names its imports to maintain clarity in what is used and where it comes from.","category":"page"},{"location":"core.html#Maps.jl","page":"Core –- Parts and Usage Overview","title":"Maps.jl","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"Modules = [Maps]","category":"page"},{"location":"core.html#InformativeSampling.Maps","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Maps","text":"This module contains types for holding and handling real and simulated data. Mainly used by, but foundational for the other parts too.\n\nMain public types and functions:\n\nBounds\nMap\ncellToPoint\ngenerateAxes\ngetBounds\npointToCell\nrandomPoint\nres\n\n\n\n\n\n","category":"module"},{"location":"core.html#InformativeSampling.Maps.Bounds","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Maps.Bounds","text":"struct NamedTuple{(:lower, :upper), Tuple{Vector{Float64}, Vector{Float64}}}\n\nThe bounds of the region. Consists of the lower and upper bounds, each a list of floating-point values.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Maps.Map","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Maps.Map","text":"A general type for holding multidimensional data (usually a matrix) along with associated dimension bounds. It's main purpose is to handle the conversion between world coordinates and grid indices internally. Converting between the two representations treats rows as the first variable (x-axis), columns as the second (y-axis), and so on.\n\nIts typical use is to act as a 2D map of some value that can be sampled. A Map will return the value of the grid cell that a given point falls within. In other words, the map value is constant within each cell. One can also think of this as a nearest-neighbor approximation.\n\nEach cell index is treated as the center of its cell. Thus the map's lower bound is at the center of the first cell and the map's upper bound is at the center of the last cell.\n\nAlso made to function directly like a built-in N-dimensional array by sub-typing and implementing the base methods.\n\nFields:\n\ndata::AbstractArray: N-dimensional array of data\nbounds::@NamedTuple{lower::Vector{Float64}, upper::Vector{Float64}}: vectors of lower and upper bounds, defaults to zeros and ones\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Maps.Map-Tuple{Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Maps.Map","text":"Method accepts a single vector (the location), returns a scalar (the value at that point).\n\nExamples\n\ndata = reshape(1:25, 5, 5)\nbounds = (\n    lower = [0.0, 0.0],\n    upper = [1.0, 1.0]\n)\nm = Map(data, bounds)\nm2 = Map(data) # bounds will be zero to one\n\nx = [.2, .75]\nval = m(x) # returns the value at a single 2D point\nval2 = m[1,4] # can also use as if it's just the underlying matrix\n\n\n\n\n\n","category":"method"},{"location":"core.html#Base.rand-Tuple{InformativeSampling.Maps.Map}","page":"Core –- Parts and Usage Overview","title":"Base.rand","text":"rand(map::InformativeSampling.Maps.Map) -> Tuple{Any, Any}\n\n\nGenerates a random point in the map. Returns the location and its value.\n\nExamples\n\ndata = reshape(1:25, 5, 5)\nmap = Map(data)\nrand(map)\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Maps.cellToPoint-Tuple{Any, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Maps.cellToPoint","text":"cellToPoint(ci, map) -> Any\n\n\nTakes in a CartesianIndex and a Map and returns a point in world-coordinates.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Maps.checkBounds-Tuple{Any, InformativeSampling.Maps.Map}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Maps.checkBounds","text":"checkBounds(x, map::InformativeSampling.Maps.Map) -> Any\n\n\nFunction emits error if location is outside of map bounds.\n\nExamples\n\nx = [.2, .75]\ndata = reshape(1:25, 5, 5)\nmap = Map(data)\ncheckBounds(x, map) # no error thrown\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Maps.generateAxes-Tuple{Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Maps.generateAxes","text":"generateAxes(map) -> Tuple{Any, Any}\n\n\nMethod to generate the x, y, etc. axes and points of a Map. Useful for plotting.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Maps.getBounds-Tuple{InformativeSampling.Maps.Map}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Maps.getBounds","text":"Get the lower and upper bounds of the map.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Maps.pointToCell-Tuple{Any, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Maps.pointToCell","text":"pointToCell(x, map) -> Any\n\n\nTakes in a point in world-coordinates and a Map and returns a CartesianIndex for the underlying array.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Maps.randomPoint-Tuple{InformativeSampling.Maps.Map}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Maps.randomPoint","text":"randomPoint(map::InformativeSampling.Maps.Map) -> Any\n\n\nGenerates a random point in the map. Returns the location.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Maps.res-Tuple{Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Maps.res","text":"res(map) -> Any\n\n\nReturns the resolution for each dimension of the given Map as a vector.\n\n\n\n\n\n","category":"method"},{"location":"core.html#Missions.jl","page":"Core –- Parts and Usage Overview","title":"Missions.jl","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"Modules = [Missions]","category":"page"},{"location":"core.html#InformativeSampling.Missions","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Missions","text":"This module contains functions for initializing mission data and the function for running the entire search mission. The entry-point to the actual informative sampling. This contains the main loop and most of the usage of Samples and BeliefModels.\n\nMain public types and functions:\n\nMission\nreplay\n\n\n\n\n\n","category":"module"},{"location":"core.html#InformativeSampling.Missions.Mission","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Missions.Mission","text":"The main function that runs the informative sampling routine. For each iteration, a sample location is selected, a sample is collected, the belief model is updated, and visuals are possibly shown. The run finishes when the designated number of samples is collected.\n\nInputs:\n\nfunc: any function to be run at the end of the update loop, useful for visualization or saving data (default does nothing)\nsamples: a vector of samples, this can be used to jump-start a mission or resume a previous mission (default empty)\nbeliefs: a vector of beliefs, this pairs with the previous argument (default empty)\nseed_val: the seed for the random number generator, an integer (default 0)\nsleep_time: the amount of time to wait after each iteration, useful for visualizations (default 0)\n\nOutputs:\n\nsamples: a vector of new samples collected\nbeliefs: a vector of probabilistic representations of the quantities being searched for, one for each sample collection\n\nExamples\n\nusing Missions: simMission\n\nmission = simMission(num_samples=10) # create the specific mission\nsamples, beliefs = mission(visuals=true, sleep_time=0.5) # run the mission\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Missions.Mission-2","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Missions.Mission","text":"Fields:\n\noccupancy::Any: an occupancy map, true in cells that are occupied\nsampler::Any: a function that returns a measurement value for any input\nnum_samples::Any: the number of samples to collect in one run\nsampleCostType::Any: a constructor for the function that returns the (negated) value of taking a sample (default DistScaledEIGF)\nweights::Any: weights for picking the next sample location\nstart_locs::Any: the locations that should be sampled first (default [])\nprior_samples::Any: any samples taken previously (default empty)\nkernel::Any: the kernel to be used in the belief model (default multiKernel)\nmeans::Any: whether or not to use a non-zero mean for each quantity and to learn means (default (true, false))\nnoise::Any: a named tuple of noise value(s) and if learned further (default (0.0, false))\nuse_cond_pdf::Any: whether or not to use the conditional distribution of the data to train the belief model (default false)\nhyp_drop::Any: whether or not to drop hypotheses and settings for it (default (false, 10, 5, 0.4))\n\nDefined as a keyword struct, so all arguments are passed in as keywords:\n\nmission = Mission(; occupancy,\n                  sampler,\n                  num_samples,\n                  sampleCostType,\n                  weights,\n                  start_locs,\n                  prior_samples,\n                  noise,\n                  kernel)\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Missions.replay-Tuple{Any, InformativeSampling.Missions.Mission, Any, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Missions.replay","text":"replay(\n    func,\n    M::InformativeSampling.Missions.Mission,\n    full_samples,\n    beliefs;\n    sleep_time\n)\n\n\nReplays a mission that has already taken place. Mainly for visualization purposes.\n\nInputs:\n\nfunc: any function to be run at the end of the update loop, useful for\n\nvisualization or saving data (default does nothing)\n\nfull_samples: a vector of samples\nbeliefs: a vector of beliefs\nsleep_time: the amount of time to wait after each iteration, useful for\n\nvisualizations (default 0)\n\n\n\n\n\n","category":"method"},{"location":"core.html#BeliefModels.jl","page":"Core –- Parts and Usage Overview","title":"BeliefModels.jl","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"Modules = [BeliefModels]","category":"page"},{"location":"core.html#InformativeSampling.BeliefModels","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.BeliefModels","text":"This module contains everything to do with what is inferred about values in the environment. In practical terms: means, variances, and correlations. This is all built on Gaussian Processes.\n\nMain public types and functions:\n\nBeliefModel\nfullCov\nmeanDerivAndVar\noutputCorMat\noutputCovMat\n\n\n\n\n\n","category":"module"},{"location":"core.html#InformativeSampling.BeliefModels.BeliefModel","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.BeliefModels.BeliefModel","text":"struct BeliefModel{T}\n\nBelief model struct and function for multiple outputs with 2D inputs.\n\nDesigned on top of a Multi-output Gaussian Process, but can still be used with a single output.\n\nIts interface: X -> μ, σ (SampleInputs -> means, standard deviations)\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.BeliefModels.BeliefModel-Tuple{Any, @NamedTuple{lower::Vector{Float64}, upper::Vector{Float64}}}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.BeliefModels.BeliefModel","text":"BeliefModel(\n    samples,\n    bounds::@NamedTuple{lower::Vector{Float64}, upper::Vector{Float64}};\n    N,\n    kernel,\n    means,\n    noise,\n    use_cond_pdf\n) -> InformativeSampling.BeliefModels.BeliefModel{typeof(InformativeSampling.Kernels.multiKernel)}\n\n\nCreates and returns a BeliefModel with hyperparameters trained and conditioned on the samples given. Lower and upper bounds are used to initialize one of the hyperparameters.\n\nA noise standard deviation can optionally be passed in either as a single scalar value for all samples or a vector of values, one for each sample.\n\nExamples\n\n# create a BeliefModel\nbeliefModel = BeliefModel([M.prior_samples; samples], bounds)\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.BeliefModels.BeliefModel-Tuple{Tuple{Vector{Float64}, Int64}}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.BeliefModels.BeliefModel","text":"Inputs:\n\nX: a single sample input or an array of multiple\nfull_cov: (optional) if this is true, returns the full covariance matrix in place of the vector of standard deviations\n\nOutputs:\n\nμ, σ: a pair of expected value(s) and uncertainty(s) for the given point(s)\n\nExamples\n\nX = [([.1, .2], 1),\n     ([.2, .1], 2)]\nμ, σ = beliefModel(X) # result: [μ1, μ2], [σ1, σ2]\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.BeliefModels.createLossFunc-NTuple{5, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.BeliefModels.createLossFunc","text":"createLossFunc(\n    X,\n    Y_vals,\n    Y_errs,\n    kernel,\n    use_cond_pdf\n) -> InformativeSampling.BeliefModels.var\"#15#16\"\n\n\nThis function creates the loss function for training the GP. The negative log marginal likelihood is used.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.BeliefModels.fullCov-Tuple{InformativeSampling.BeliefModels.BeliefModel, AbstractArray{Tuple{Vector{Float64}, Int64}}}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.BeliefModels.fullCov","text":"fullCov(\n    beliefModel::InformativeSampling.BeliefModels.BeliefModel,\n    X::AbstractArray{Tuple{Vector{Float64}, Int64}}\n) -> Any\n\n\nReturns the full covariance matrix for the belief model.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.BeliefModels.meanDerivAndVar-Tuple{InformativeSampling.BeliefModels.BeliefModel, Tuple{Vector{Float64}, Int64}}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.BeliefModels.meanDerivAndVar","text":"meanDerivAndVar(\n    beliefModel::InformativeSampling.BeliefModels.BeliefModel,\n    x::Tuple{Vector{Float64}, Int64}\n) -> Any\n\n\nReturns the normed gradient of the mean of the belief model and its variance.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.BeliefModels.optimizeLoss-Tuple{Any, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.BeliefModels.optimizeLoss","text":"optimizeLoss(lossFunc, θ0; solver, iterations) -> Any\n\n\nRoutine to optimize the lossFunc and return the optimal parameters θ.\n\nCan pass in a different solver. NelderMead is picked as default for better speed with about the same performance as LFBGS.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.BeliefModels.outputCorMat-Tuple{InformativeSampling.BeliefModels.BeliefModel}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.BeliefModels.outputCorMat","text":"outputCorMat(beliefModel::BeliefModel)\n\nGives the correlation matrix between all outputs from the hyperparameters.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.BeliefModels.outputCovMat-Tuple{InformativeSampling.BeliefModels.BeliefModel{typeof(InformativeSampling.Kernels.multiKernel)}}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.BeliefModels.outputCovMat","text":"outputCovMat(\n    bm::InformativeSampling.BeliefModels.BeliefModel{typeof(InformativeSampling.Kernels.multiKernel)}\n) -> Any\n\n\nGives the covariance matrix between all outputs from the hyperparameters.\n\n\n\n\n\n","category":"method"},{"location":"core.html#Samples.jl","page":"Core –- Parts and Usage Overview","title":"Samples.jl","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"Modules = [Samples]","category":"page"},{"location":"core.html#InformativeSampling.Samples","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples","text":"This module contains everything to do with sampling values in the environment. Its alias types Location and SampleInput are fundamental pieces for BeliefModels as well.\n\nMain public types and functions:\n\nLocation\nMapsSampler\nSample\nSampleInput\nUserSampler\nselectSampleLocation\ntakeSamples\n\n\n\n\n\n","category":"module"},{"location":"core.html#InformativeSampling.Samples.Location","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.Location","text":"mutable struct Array{Float64, 1} <: DenseVector{Float64}\n\nLocation of sample\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.MapsSampler","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.MapsSampler","text":"Handles samples of the form (location, quantity) to give the value from the right map. Internally a tuple of Maps.\n\nConstructor can take in a tuple or vector of Maps or each Map as a separate argument.\n\nExamples\n\nss = MapsSampler(Map(zeros(5, 5)), Map(ones(5, 5)))\n\nloc = [.2, .75]\nss(loc) # result: [0, 1]\nss((loc, 2)) # result: 1\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.Sample","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.Sample","text":"Struct to hold the input and output of a sample.\n\nFields:\n\nx::Tuple{Vector{Float64}, Int64}: the sample input, usually a location and sensor id\ny::Any: the sample output or observation, a scalar\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.SampleInput","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.SampleInput","text":"struct Tuple{Vector{Float64}, Int64}\n\nSample input, the combination of: (Location, sensor index)\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.SampleOutput","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.SampleOutput","text":"struct Tuple{Float64, Float64}\n\nValue of sample measurement, the measurement mean and standard deviation\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.UserSampler","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.UserSampler","text":"A sampler that asks the user to input measurement values, one for each quantity at the given location.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Samples.selectSampleLocation-Tuple{Any, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.selectSampleLocation","text":"selectSampleLocation(sampleCost, bounds) -> AbstractArray\n\n\nThe optimization of choosing a best single sample location.\n\nInputs:\n\nsampleCost: a function from sample location to cost (x->cost(x))\nbounds: map lower and upper bounds\n\nReturns the sample location, a vector\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Samples.takeSamples-Tuple{Any, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Samples.takeSamples","text":"takeSamples(loc, sampler) -> Any\n\n\nPulls a ground truth value from a given location and constructs a Sample object to hold them both.\n\nInputs:\n\nloc: the location to sample\nsampler: a function that returns ground truth values\nquantities: (optional) a vector of integers which represent which quantities to sample, defaults to all of them\n\nOutputs a vector of Samples containing input x and measurement y\n\n\n\n\n\n","category":"method"},{"location":"core.html#SampleCosts.jl","page":"Core –- Parts and Usage Overview","title":"SampleCosts.jl","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"Modules = [SampleCosts]","category":"page"},{"location":"core.html#InformativeSampling.SampleCosts","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts","text":"This module holds a variety of SampleCost functions used by Samples.jl in selecting a new sample location. The purpose is to pick the location that will minimize the given function.\n\nEach sample cost function in this module is a subtype of the abstract SampleCost type. Their common interface consists of two functions:\n\nvalues(sampleCost, location): returns the values of the terms (μ, σ, τ, P);\n                                this is typically what each subtype will override;\n                                in all of these, μ = belief model mean, σ = belief model std,                                 τ = travel distance, P = proximity value;\n                                all of these are for the specific location\nsampleCost(location): the actual sample cost at the location; it has a                         default method explained in SampleCost;\n                        for the equations the location is denoted x\n\nMany of these were experiment cost functions and aren't recommended. The main ones recommended for use, in order, are\n\nDistScaledEIGF\nEIGF\nMIPT\nOnlyVar\n\nOthers can be useful if one wants to do some more experimentation. Note that all these functions are currently hardcoded to use the first quantity as the objective quantity unless otherwise stated. Unless explicitly used, the distance value is generally used to make sure unreachable locations are forbidden (their value will be Inf).\n\nMain public types and functions:\n\nDerivVar\nDistLogEIGF\nDistProx\nDistScaledDerivVar\nDistScaledEIGF\nEIGF\nInfoGain\nLogLikelihood\nLogLikelihoodFull\nLogNormed\nMIPT\nOnlyVar\nSampleCost\nVarTrace\nvalues\n\n\n\n\n\n","category":"module"},{"location":"core.html#InformativeSampling.SampleCosts.DerivVar","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.DerivVar","text":"Uses the norm of the derivative of the belief model mean and the belief model variance:\n\nC(x) = - w_1  leftlVert fracpartial μpartial x(x) rightrVert^2 - w_2  σ^2(x)\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.DistLogEIGF","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.DistLogEIGF","text":"A variation on EIGF that takes the logarithm of the variance and adds a distance cost term that is normalized by the average of the region dimensions:\n\nC(x) = - w_1  (μ(x) - y(x_c))^2 - w_2  log(σ^2(x)) +\n       w_3  β  fracτ(x)leftlVert boldsymbolell_d rightrVert_1\n\nwhere β is a parameter to delay the distance effect until a few samples have been taken.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.DistProx","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.DistProx","text":"Combines the average mean value, average standard deviation, travel distance, and proximity as terms:\n\nC(x) = - w_1  μ_mathrmave(x) - w_2  σ_mathrmave(x) +\n       w_3  τ(x) + w_4  P(x)\n\nwhere P(x) = sum_i(fracmin(boldsymbolell_d)4  mathrmdist_i)^3. Averages are performed over all quantities.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.DistScaledDerivVar","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.DistScaledDerivVar","text":"Uses the norm of the derivative of the belief model mean and the belief model variance, then scales it all by a normalized travel distance:\n\nC(x) = frac- w_1  leftlVert fracpartial μpartial x(x) rightrVert^2 - w_2  σ^2(x)\n       1 + β  fracτ(x)leftlVert boldsymbolell_d rightrVert_1\n\nwhere β is a parameter to delay the distance effect until a few samples have been taken.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.DistScaledEIGF","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.DistScaledEIGF","text":"Augments EIGF with a factor to scale by a normalized travel distance:\n\nC(x) = frac- w_1  (μ(x) - y(x_c))^2 - w_2  σ^2(x)\n1 + β  fracτ(x)leftlVert boldsymbolell_d rightrVert_1\n\nwhere β is a parameter to delay the distance effect until a few samples have been taken.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.EIGF","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.EIGF","text":"Expected Informativeness for Global Fit (EIGF). This function is adapted from [Lam] through added weights to choose the balance between exploration and exploitation. It has the form:\n\nC(x) = - w_1  (μ(x) - y(x_c))^2 - w_2  σ^2(x)\n\nwhere x_c is the nearest collected sample location.\n\n[Lam]: Lam, C Q (2008) Sequential adaptive designs in computer experiments for response surface model fit (Doctoral dissertation). The Ohio State University.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.InfoGain","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.InfoGain","text":"Derived from the idea of information gain across the region. Returns the entropy of a set of points (10x10 grid) given the new sample location. Minimizing this entropy is equivalent to maximizing information gain since the entropy before the sample is always the same.\n\nThis function is very computationally expensive, which is why the test grid is set at 10x10.\n\nIt has the form:\n\nC(x) = log Σ\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.LogLikelihood","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.LogLikelihood","text":"Idea derived from the log likelihood of query location. Similar to EIGF, the measured value from the nearest sample is used:\n\nC(x) = - w_1  left( fracμ(x) - y(x_c)σ_n right)^2 - w_2  log (σ^2(x))\n\nwhere x_c is the nearest collected sample location, and σ_n is the noise.\n\nThis function was seen to work well but hasn't undergone extensive tests. There is still some question about the theory and the use of noise parameter vs signal amplitude parameter.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.LogLikelihoodFull","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.LogLikelihoodFull","text":"A test of the log likelihood idea but using a weighted sum of all measured sample values, not just the nearest one:\n\nC(x) = - w_1  frac1sum_i k(x x_i) sum_i k(x x_i) *\n       left( fracμ(x) - y(x_i)σ_n right)^2 - w_2  log (σ^2(x))\n\nwhere x_i is each collected sample location, and σ_n is the noise.\n\nThis function's performance wasn't satisfactory.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.LogNormed","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.LogNormed","text":"Combines the average belief value and the log of the average uncertainty value of all quantities. All belief and uncertainty values are first normalized by the maximum belief value of that quantity. It has the form:\n\nC(x) = - w_1  μ_textrmnorm-ave(x) - w_2  log (σ_textrmnorm-ave(x))\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.MEPE","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.MEPE","text":"This was a cost function being considered but wasn't finished. Taken from [Liu].\n\n[Liu]: Liu H, Cai J, Ong Y (2017) An adaptive sampling approach for kriging metamodeling by maximizing expected prediction error. Comput Chem Eng 106:171–182\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.MIPT","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.MIPT","text":"A simple cost function that doesn't use a belief model but works purely on distances. It returns the negated distance to the nearest sample:\n\nC(x) = - min_i leftlVert x - x_i rightrVert\n\nUseful when maximizing distance between samples.\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.OnlyVar","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.OnlyVar","text":"Returns the negated variance of the belief model at the query location:\n\nC(x) = - σ^2\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.SampleCost","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.SampleCost","text":"Typically construct a SampleCost through SampleCostType(occupancy, samples, beliefModel, quantities, weights)\n\nA pathCost is constructed automatically from the other arguments.\n\nThis object can then be called to get the cost of sampling at a location: sampleCost(x)\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.SampleCost-Tuple{Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.SampleCost","text":"Cost to take a new sample at a location x. This is a fallback method that calculates a simple linear combination of all the values of a SampleCost.\n\nHas the form:\n\nC(x) = - w_1  μ(x) - w_2  σ(x) + w_3  τ(x) + w_4  P(x)\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.SampleCosts.VarTrace","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.VarTrace","text":"Similar to InfoGain but uses only variances rather than the full covariance matrix, which is the same as the trace instead of the log determinant. This reduces computation but is still more costly than a single point estimate. This uses a 20x20 grid of test points.\n\nIt has the form:\n\nC(x) = textrmtr(Σ)\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.SampleCosts.values-Tuple{InformativeSampling.SampleCosts.SampleCost, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.SampleCosts.values","text":"values(sc::InformativeSampling.SampleCosts.SampleCost, loc)\n\n\nReturns the values to be used to calculate the sample cost (belief mean, standard deviation, travel distance, sample proximity).\n\nEach concrete subtype of SampleCost needs to implement.\n\nThis can be a useful function to inspect values during optimization.\n\n\n\n\n\n","category":"method"},{"location":"core.html#Paths.jl","page":"Core –- Parts and Usage Overview","title":"Paths.jl","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"Modules = [Paths]","category":"page"},{"location":"core.html#InformativeSampling.Paths","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Paths","text":"This module contains types and functions for searching for paths on a 2D grid using A*. Its main use is to get the path cost (distance), but it can return the full path as well.\n\nMain public types and functions:\n\nPathCost\nfinalOrientation\ngetPath\n\n\n\n\n\n","category":"module"},{"location":"core.html#InformativeSampling.Paths.PathCost","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Paths.PathCost","text":"Struct for PathCost function data. Previous computations are kept track of in its data. Can be used multiple times for the same start cell, saving computation.\n\nThe cells of the costMatrix contain the distance to them from the start cell. NaN is a placeholder meaning no path has been calculated to that cell yet. Inf means that cell is not reachable from the start cell.\n\nFields:\n\nstart::Any\ncostMatrix::Any\nresolution::Any\ndiffs::Any\ndist::Any\nheuristic::Any\nfrontier::Any\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.Paths.PathCost-Tuple{Any, Any, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Paths.PathCost","text":"PathCost(\n    start,\n    occupancy,\n    resolution;\n    diagonals,\n    dist,\n    heuristic\n) -> InformativeSampling.Paths.PathCost\n\n\nThe constructor initializes the path search algorithm, created for each new start cell.\n\nInputs:\n\nstart: the starting cell in the matrix\noccupancy: a matrix indicating which cells are occupied\nresolution: a vector of the width and height of each cell\ndiagonals: whether to include connectivity to diagonal cells or not (default true)\ndist: function to compute distance from current to next cell (default weightedEuclidian)\nheuristic: function to compute estimated distance from current to goal cell (default weightedEuclidian)\n\nNote: this type and associated methods can in fact be used with any N-dimensional cost array, not just a matrix.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Paths.PathCost-Tuple{Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Paths.PathCost","text":"Search for a path to a desired goal cell using the A* algorithm.\n\nReturns the path cost, which will be Inf if it is unreachable.\n\nIf the cells of the path are desired, use the getPath function.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Paths.finalOrientation-Tuple{InformativeSampling.Paths.PathCost, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Paths.finalOrientation","text":"finalOrientation(\n    S::InformativeSampling.Paths.PathCost,\n    goal\n) -> Any\n\n\nGiven a PathCost and a goal point, this function returns the angle of the direction from penultimate cell to goal cell, effectively the direction at the end of the path to the goal.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.Paths.getPath-Tuple{InformativeSampling.Paths.PathCost, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.Paths.getPath","text":"getPath(\n    S::InformativeSampling.Paths.PathCost,\n    goal\n) -> Vector\n\n\nGiven a PathCost and a goal point, this function returns the entire list of cells from the start to the goal. Only useful to be called after the PathCost object is called with the goal cell.\n\n\n\n\n\n","category":"method"},{"location":"core.html#ROSInterface.jl","page":"Core –- Parts and Usage Overview","title":"ROSInterface.jl","text":"","category":"section"},{"location":"core.html","page":"Core –- Parts and Usage Overview","title":"Core –- Parts and Usage Overview","text":"Modules = [ROSInterface]","category":"page"},{"location":"core.html#InformativeSampling.ROSInterface","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.ROSInterface","text":"This module contains the interface for passing data to and from other ROS nodes. It sets up an informative_sampling node and provides methods to handle the data. This is designed specifically for communication with Swagbot.\n\nMain public types and functions:\n\nROSSampler\n\n\n\n\n\n","category":"module"},{"location":"core.html#InformativeSampling.ROSInterface.ROSSampler","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.ROSInterface.ROSSampler","text":"A struct that stores information for communicating with Swagbot.\n\nObjects of this type can be used as samplers in missions, meaning they can be called with a SampleInput to return its value. This object also has a length, which is the length of the number of its subscriptions and can be iterated over to get the name of each one.\n\nFields:\n\ndata_topics::Vector{T} where T<:Union{String, Tuple{String, String}}: vector of topic names that will be subscribed to to receive measurements\ndone_topic::Any: topic name that publishes a message to signify the traveling is done\npub_topic::Any: the publisher topic name\npublisher::Any: the publisher topic object, created automatically from a given name\n\n\n\n\n\n","category":"type"},{"location":"core.html#InformativeSampling.ROSInterface.ROSSampler-Tuple{Any, Any, Any}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.ROSInterface.ROSSampler","text":"ROSSampler(\n    data_topics,\n    done_topic,\n    pub_topic\n) -> InformativeSampling.ROSInterface.ROSSampler\n\n\nCreating a ROSSampler object requires a vector of topics to subscribe to for measurement data, essentially the list of sensors onboard the robot to listen to. Each element of this list should be a 2-tuple of topics that will transmit the value and error for each sensor. This constructor initializes a ROS node and sets up a publisher to pub_topic.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.ROSInterface.ROSSampler-Tuple{Tuple{Vector{Float64}, Int64}}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.ROSInterface.ROSSampler","text":"function (R::ROSSampler{String})(new_index::SampleInput)\n\nReturns a single value from the sample location of the chosen quantity.  It does this by first publishing the next location to sample. Once the location is sampled, it calls out to each topic in sequence and waits for its message.\n\nCurrently will be unused.\n\nfunction (R::ROSSampler{NTuple{2, String}})(new_index::SampleInput)\n\nReturns a single value and its error from the sample location of the chosen quantity.  It does this by first publishing the next location to sample. Once the location is sampled, it calls out to each topic in sequence and waits for its message.\n\nCurrently will be unused.\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.ROSInterface.ROSSampler-Tuple{Vector{Float64}}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.ROSInterface.ROSSampler","text":"function (R::ROSSampler{String})(new_loc::Location)\n\nReturns a vector of values from the sample location, one for each sensor measurement available. It does this by first publishing the next location to sample. Once the location is sampled, it calls out to each topic in sequence and waits for its message.\n\nExamples\n\ndata_topics = [\n    \"/value1\",\n    \"/value2\"\n]\n\ndone_topic = \"sortie_finished\"\npub_topic = \"latest_sample\"\n\nsampler = ROSSampler(data_topics, done_topic, pub_topic)\n\nlocation = [.1, .3]\n[value1, value2] = sampler(location)\n\nfunction (R::ROSSampler{NTuple{2, String}})(new_loc::Location)\n\nReturns a vector of (value, error) pairs from the sample location, one for each sensor measurement available. It does this by first publishing the next location to sample. Once the location is sampled, it calls out to each topic in sequence and waits for its message.\n\nExamples\n\ndata_topics = [\n    (\"/value1\", \"/error1\"),\n    (\"/value2\", \"/error2\")\n]\n\ndone_topic = \"sortie_finished\"\npub_topic = \"latest_sample\"\n\nsampler = ROSSampler(data_topics, done_topic, pub_topic)\n\nlocation = [.1, .3]\n[(value1, error1), (value2, error2)] = sampler(location)\n\n\n\n\n\n","category":"method"},{"location":"core.html#InformativeSampling.ROSInterface.publishNextLocation-Tuple{Any, Vector{Float64}}","page":"Core –- Parts and Usage Overview","title":"InformativeSampling.ROSInterface.publishNextLocation","text":"publishNextLocation(publisher, new_loc::Vector{Float64})\n\n\nInternal function used to send the next location to Swagbot.\n\n\n\n\n\n","category":"method"},{"location":"julia_tips.html#Julia-Tips","page":"Julia Tips","title":"Julia Tips","text":"","category":"section"},{"location":"julia_tips.html#Development-Environment","page":"Julia Tips","title":"Development Environment","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"These instructions focus on getting started up just using the REPL, which can be a sufficient set of tools. If you want to use an IDE, VSCode with the Julia extension is the main one recommended. It is supported by the Julia contributors and the community as a whole. You'll need to read their docs to learn how to use it.","category":"page"},{"location":"julia_tips.html#REPL","page":"Julia Tips","title":"REPL","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Julia ships with a useful REPL that combines an interpreter, a documentation browser, a package manager, and a shell. The four modes are accessed by typing the following keys:","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Interpreter: default mode\nHelp: ?\nPackages: ]\nShell: ;","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Type backspace or ctrl-c to exit a mode.","category":"page"},{"location":"julia_tips.html#Compilation","page":"Julia Tips","title":"Compilation","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Julia code gets compiled the first time you run it. This means the first run will be slower and later ones much faster. This is also true when loading packages with using or import. So the typical way to run julia code is through a REPL that is kept open between runs in order to not re-compile. If a script is run directly from the command line using the julia interpreter, it will be re-compiled every time. Running code within an IDE will typically keep a REPL open for you.","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Note: Since Julia 1.9 load and first-execution times have been considerably reduced for modules that have not changed. It does this through pre-compilation and caching. Highly recommended. A few extra seconds on first run time are typical, similar to re-compiling C++ code before running it.","category":"page"},{"location":"julia_tips.html#Revise.jl","page":"Julia Tips","title":"Revise.jl","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"This is a great package to use when developing code (not needed when only running it). Normally to update methods and variables that have changed, you have to manually re-run the changed code in the REPL. This package tracks modules that you have included with using or import and automatically updates the running environment with any changes. Simply run using Revise before using anything else (i.e. running the Main.jl file) and all your changes within the project will be tracked.","category":"page"},{"location":"julia_tips.html#Unchangeable-stuff","page":"Julia Tips","title":"Unchangeable stuff","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Julia doesn't allow changing type definitions. This means if you need to change what is within a struct or you need use the name of a function for something else, you will need to restart the REPL.","category":"page"},{"location":"julia_tips.html#Functions-and-Methods","page":"Julia Tips","title":"Functions and Methods","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"In Julia lingo, a function is a type given to a family of methods, which are all called with the given function name. The methods are specific implementations or instantiations of that function, which are based on the number and types of the arguments passed in.","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Example:","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"julia> length # the function\nlength (generic function with 226 methods)\n\njulia> ?length(\"text\") # one method\nlength(s::AbstractString) -> Int\n...continued...\n\njulia> ?length([1,2,3]) # a different method\nlength(A::AbstractArray)\n...continued...","category":"page"},{"location":"julia_tips.html#Timing,-Profiling,-and-Debugging","page":"Julia Tips","title":"Timing, Profiling, and Debugging","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"The following packages can be useful when developing and analyzing the code.","category":"page"},{"location":"julia_tips.html#Timing","page":"Julia Tips","title":"Timing","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"The easiest way to time code is simply by putting @time in front of a line of code. If you want to time multiple lines, put them inside a @time begin ... end block.","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"To automate multiple runs of the code and get statistical information, use BenchmarkTools.jl and the @benchmark or @btime macros.","category":"page"},{"location":"julia_tips.html#Profiling","page":"Julia Tips","title":"Profiling","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Reference: https://docs.julialang.org/en/v1/manual/profile/","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"using Profile","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Same as timing, just put @profile before the code you want profiled. To see the output run Profile.print().","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"I like using StatProfilerHTML.jl for viewing the output. Can also use ProfileView.jl. They each have their own shortcut commands for profiling and viewing. See their pages.","category":"page"},{"location":"julia_tips.html#Debugging","page":"Julia Tips","title":"Debugging","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Reference: https://github.com/JuliaDebug/Debugger.jl","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"using Debugger","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"Put @run or @enter before code to debug. Use the commands from the docs in the REPL.","category":"page"},{"location":"julia_tips.html#Finding-source-module-of-object","page":"Julia Tips","title":"Finding source module of object","text":"","category":"section"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"To get the module that an object comes from, you can use","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"parentmodule(ImportedType) # will tell you which module a function or type comes from\nparentmodule(typeof(var)) # for the object a variable contains, get the type first","category":"page"},{"location":"julia_tips.html","page":"Julia Tips","title":"Julia Tips","text":"In this project all names used are explicitly imported at the top of the file to help new developers.","category":"page"},{"location":"application.html#Application-–-Parts-and-Usage-Overview","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"Scripts that run the informative sampling code. This is the starting place for use of the repository and it uses the other parts: core and utils.","category":"page"},{"location":"application.html#missions","page":"Application –- Parts and Usage Overview","title":"missions","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The place where code to run missions is located.","category":"page"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The launching point for running the informative sampling missions. The main steps are initializing data, running the algorithm, and visualizing/saving results.","category":"page"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The example.jl script can be run to see the full code in action.","category":"page"},{"location":"application.html#scripts","page":"Application –- Parts and Usage Overview","title":"scripts","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The place where code to analyze saved data is located.","category":"page"},{"location":"application.html#ros","page":"Application –- Parts and Usage Overview","title":"ros","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"A python files used to test simple usage with ROS.","category":"page"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"Also contains the server.jl script which handles ROS service requests.","category":"page"},{"location":"application.html#maps","page":"Application –- Parts and Usage Overview","title":"maps","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The place where maps used as data are stored.","category":"page"},{"location":"application.html#output","page":"Application –- Parts and Usage Overview","title":"output","text":"","category":"section"},{"location":"application.html","page":"Application –- Parts and Usage Overview","title":"Application –- Parts and Usage Overview","text":"The place that files are saved from the code by default.","category":"page"},{"location":"utilities.html#Utilities-–-Parts-and-Usage-Overview","page":"Utilities –- Parts and Usage Overview","title":"Utilities –- Parts and Usage Overview","text":"","category":"section"},{"location":"utilities.html","page":"Utilities –- Parts and Usage Overview","title":"Utilities –- Parts and Usage Overview","text":"Modules for auxiliary functions used with the core informative sampling.","category":"page"},{"location":"utilities.html#DataIO.jl","page":"Utilities –- Parts and Usage Overview","title":"DataIO.jl","text":"","category":"section"},{"location":"utilities.html","page":"Utilities –- Parts and Usage Overview","title":"Utilities –- Parts and Usage Overview","text":"Modules = [DataIO]","category":"page"},{"location":"utilities.html#InformativeSamplingUtils.DataIO","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO","text":"A module for handling data in and out.\n\nMain public types and functions:\n\nimgToMap\nmaps_dir\nnormalize\noutput_dir\noutput_ext\nproduceMap\nproduceMaps\nsave\nsaveBeliefMapToPng\nspatialAve\n\n\n\n\n\n","category":"module"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.maps_dir","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.maps_dir","text":"The default directory containing the maps that can be used as data during simulated sampling.\n\n\n\n\n\n","category":"constant"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.output_dir","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.output_dir","text":"The default output directory where files can be saved.\n\n\n\n\n\n","category":"constant"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.output_ext","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.output_ext","text":"The default extension for saved output files.\n\n\n\n\n\n","category":"constant"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.GaussGroundTruth","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.GaussGroundTruth","text":"Struct/function for generating ground truth values from a linear combination of gaussian peaks.\n\nExamples\n\nGaussGroundTruth(peaks) # pass in a list of Peaks\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.GaussGroundTruth-Tuple{Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.GaussGroundTruth","text":"Produces ground-truth value(s) for a point or list of points. Accepts a single vector, a vector of vectors, or a matrix of column vectors.\n\nEach probability distribution component is divided by its own peak height and the highest of all the peaks before being added into the total. This causes the entire ground truth map to have a max value of (about) 1.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.Peak","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.Peak","text":"Used within a GaussGroundTruth. Holds a 2D normal distribution and the desired height of the peak.\n\n\n\n\n\n","category":"type"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.Peak-Tuple{Any, Any, Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.Peak","text":"Inputs:\n\nμ: the peak location (distribution mean)\nΣ: the peak width (distribution covariance)\nh: the peak height\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.dateTimeString","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.dateTimeString","text":"Creates a string containing the date and time separated by dashes. Can pass in a DateTime object, defaults to current time.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.imgToMap-Tuple{Any, Vararg{Any}}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.imgToMap","text":"Takes a matrix in the format created from an image, re-formats it, and returns a Map. Images view a matrix with its indexing top-down and left-right. Maps view a matrix with its indexing left-right and bottom-up.\n\nExamples\n\nusing DelimitedFiles: readdlm\n\nimage = readdlm(file_name, ',')\nbounds = (lower = [0.0, 0.0], upper = [1.0, 1.0])\nmap = imgToMap(image, bounds)\nmap = imgToMap(image) # or auto bounds\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.normalize-Tuple{Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.normalize","text":"A helper method to normalize an array so its values are within the range [0, 1].\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.produceMap-Tuple{Any, InformativeSampling.Maps.Map}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.produceMap","text":"produceMap(\n    func,\n    map::InformativeSampling.Maps.Map\n) -> Union{InformativeSampling.Maps.Map{_A, _B, _C, Float64} where {_B, _C<:AbstractArray{_A, _B}}, InformativeSampling.Maps.Map{_A, N, _C, Float64} where {N, _C<:AbstractArray{_A, N}}} where _A\n\n\nGenerates a Map from a function for chosen bounds and dimensions. Can also pass in another Map in place of bounds and dims.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.produceMaps-Tuple{InformativeSampling.BeliefModels.BeliefModel, InformativeSampling.Maps.Map}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.produceMaps","text":"produceMaps(\n    beliefModel::InformativeSampling.BeliefModels.BeliefModel,\n    map::InformativeSampling.Maps.Map;\n    quantity\n) -> Tuple{Union{InformativeSampling.Maps.Map{_A, _B, _C, Float64} where {_B, _C<:AbstractArray{_A, _B}}, InformativeSampling.Maps.Map{_A, N, _C, Float64} where {N, _C<:AbstractArray{_A, N}}} where _A, Union{InformativeSampling.Maps.Map{_A, _B, _C, Float64} where {_B, _C<:AbstractArray{_A, _B}}, InformativeSampling.Maps.Map{_A, N, _C, Float64} where {N, _C<:AbstractArray{_A, N}}} where _A}\n\n\nGenerates belief and uncertainty Maps from a belief model for chosen bounds and dimensions. Can also pass in another Map in place of bounds and dims.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.save-NTuple{4, Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.save","text":"save(\n    mission,\n    samples,\n    beliefs,\n    times;\n    animation,\n    sub_dir_name,\n    file_name\n) -> Union{Nothing, Plots.AnimatedGif}\n\n\nA collection of methods for saving data from missions, metrics, and general julia objects.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.saveBeliefMapToPng","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.saveBeliefMapToPng","text":"saveBeliefMapToPng(beliefModel, occupancy) -> Any\nsaveBeliefMapToPng(beliefModel, occupancy, file_name) -> Any\n\n\nThis is really just to give something out to munch, so it needs to be an rgba png with the last channel as the amount.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.DataIO.spatialAve","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.DataIO.spatialAve","text":"A helper method to perform a spatial average on a matrix. The extent of the average can be chosen with its default being 1.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#Visualization.jl","page":"Utilities –- Parts and Usage Overview","title":"Visualization.jl","text":"","category":"section"},{"location":"utilities.html","page":"Utilities –- Parts and Usage Overview","title":"Utilities –- Parts and Usage Overview","text":"Modules = [Visualization]","category":"page"},{"location":"utilities.html#InformativeSamplingUtils.Visualization","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization","text":"A module with methods to visualize mission data. The form displayed is determined by what data types are passed in.\n\nMain public types and functions:\n\nvis\nvisualize\n\n\n\n\n\n","category":"module"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.getAxes-Tuple{Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.getAxes","text":"getAxes(map) -> Tuple{Any, Any}\n\n\nMethod to get the x and y plotting axes. This (re)generates them only if needed and saves them into global module variables for future use.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.vis","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.vis","text":"Simple convenience function that also displays the output of any visualize function. See those.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(map::InformativeSampling.Maps.Map; ...) -> Any\nvisualize(\n    map::InformativeSampling.Maps.Map,\n    title;\n    points,\n    clim\n) -> Any\n\n\nMethod to show any Map data.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-2","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(\n    beliefModel::InformativeSampling.BeliefModels.BeliefModel,\n    samples,\n    occupancy;\n    ...\n) -> Any\nvisualize(\n    beliefModel::InformativeSampling.BeliefModels.BeliefModel,\n    samples,\n    occupancy,\n    new_loc;\n    quantity\n) -> Any\n\n\nMethod to show belief model values of mean and standard deviation and the sample locations that they were generated from. Shows two plots side-by-side.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-3","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(sampleCost, samples, occupancy) -> Any\nvisualize(sampleCost, samples, occupancy, new_loc) -> Any\n\n\nMethod to show sample cost values.\n\n\n\n\n\n","category":"function"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-Tuple{Any, Any, InformativeSampling.BeliefModels.BeliefModel, Any, Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(\n    md,\n    samples,\n    beliefModel::InformativeSampling.BeliefModels.BeliefModel,\n    sampleCost,\n    new_loc;\n    quantity\n) -> Any\n\n\nMain method to visualize the current state of a search. Generates all the other visuals through their respective methods and lays them out in a grid. Currently shows the belief model, the ground truth, and the obstacles.\n\nArguments pass through to the sub-methods that need them. res is the grid resolution when plotting continuous-valued functions and defaults to [0.01, 0.01].\n\nIf no ground truth is available, it is not plotted.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-Tuple{Any, Any, InformativeSampling.BeliefModels.BeliefModel, Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(\n    md,\n    samples,\n    beliefModel::InformativeSampling.BeliefModels.BeliefModel,\n    new_loc;\n    quantity\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-Tuple{Any, Any}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(sampler, map) -> Any\n\n\nMethod to show ground truth data from a function.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#InformativeSamplingUtils.Visualization.visualize-Tuple{Vararg{InformativeSampling.Maps.Map}}","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Visualization.visualize","text":"visualize(\n    maps::InformativeSampling.Maps.Map...;\n    titles,\n    points\n) -> Any\n\n\nMethod to show a ground truth map and up to three other prior data maps. Pass each map in as its own argument.\n\n\n\n\n\n","category":"method"},{"location":"utilities.html#Metrics.jl","page":"Utilities –- Parts and Usage Overview","title":"Metrics.jl","text":"","category":"section"},{"location":"utilities.html","page":"Utilities –- Parts and Usage Overview","title":"Utilities –- Parts and Usage Overview","text":"Modules = [Metrics]","category":"page"},{"location":"utilities.html#InformativeSamplingUtils.Metrics","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Metrics","text":"A module to calculate the metrics from a mission and belief model.\n\nMain public types and functions:\n\ncalcMetrics\n\n\n\n\n\n","category":"module"},{"location":"utilities.html#InformativeSamplingUtils.Metrics.calcMetrics","page":"Utilities –- Parts and Usage Overview","title":"InformativeSamplingUtils.Metrics.calcMetrics","text":"A collection of methods that calculates metrics from sampling missions.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"index.html","page":"Index","title":"Index","text":"This repository is divided into three parts: a core package, utilities, and an application.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"The package is the core functionality –- the general informative sampling routine. This part includes things like the belief models, map data structures, sample selection optimization, and the main mission loop.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"The utilities are things that deal with informative sampling data –- both inputs and outputs. They provide common routines to aid in constructing, visualizing, and analyzing missions.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"The application is code that uses and tests the informative sampling package in specific scenarios. It contains the data itself and scripts to run all the other code.","category":"page"},{"location":"index.html","page":"Index","title":"Index","text":"See the sections in the sidebar to learn more details. ","category":"page"}]
}
